local RockModule = {}

local TweenService = game:GetService("TweenService")

function RockModule.RayCastEffect(owner, numrocks, distance, AngleNumber, Size, Size2, Size3, Orientation, RayCastNumber1, PlaceBelow)
	local RayParams = RaycastParams.new()
	RayParams.FilterDescendantsInstances = {workspace}
	RayParams.FilterType = Enum.RaycastFilterType.Include


	local Angle = 0

	for i = 1,numrocks do
		local Part = Instance.new("Part")
		Part.Anchored = true
		Part.Size = Vector3.new(1,1,1)
		Part.CFrame = owner.CFrame * CFrame.fromEulerAnglesXYZ(0,math.rad(Angle),0) * CFrame.new(distance,1,0) * CFrame.Angles(0,0,math.rad(Orientation))

		game.Debris:AddItem(Part,20)

		local RayCast = workspace:Raycast(Part.CFrame.p,Part.CFrame.UpVector * - RayCastNumber1, RayParams)

		if RayCast then

			Part.CanCollide = false
			Part.Position = RayCast.Position + Vector3.new(0,PlaceBelow,0)
			Part.Material = RayCast.Instance.Material
			Part.Color = RayCast.Instance.Color
			Part.Size = Vector3.new(Size,Size2,Size3)
			--Part.Orientation = Vector3.new(math.random(-180, 180),math.random(-180, 180),math.random(-180, 180))
			Part.Parent = workspace.Effects

			for _, v in pairs(RayCast.Instance:GetChildren()) do
				if v:IsA("Texture") then
					v:Clone().Parent = Part
				end
			end

			local Tween = TweenService:Create(Part,TweenInfo.new(.25,Enum.EasingStyle.Bounce,Enum.EasingDirection.In),{Position = Part.Position + Vector3.new(0,5,0)}):Play()

			delay(2,function()

				local Tween = TweenService:Create(Part,TweenInfo.new(5,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{Position = Part.Position + Vector3.new(0,-11,0)}):Play()
			end)
			--end)
		end
		Angle+=AngleNumber
	end
end

return RockModule
